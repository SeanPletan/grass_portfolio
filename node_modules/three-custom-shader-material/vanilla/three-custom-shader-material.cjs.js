"use strict";const D=require("three");function H(l){const s=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(l){for(const o in l)if(o!=="default"){const f=Object.getOwnPropertyDescriptor(l,o);Object.defineProperty(s,o,f.get?f:{enumerable:!0,get:()=>l[o]})}}return s.default=l,Object.freeze(s)}const v=H(D),y=`
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump;
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`,O=`

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        csm_Bump = vec3(0.0);
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`,b=`
    varying mat4 csm_internal_vModelViewMatrix;
`,x=`
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,F=`
    varying mat4 csm_internal_vModelViewMatrix;
`,k=`
    
`,e={diffuse:"csm_DiffuseColor",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",fragNormal:"csm_FragNormal",clearcoat:"csm_Clearcoat",clearcoatRoughness:"csm_ClearcoatRoughness",clearcoatNormal:"csm_ClearcoatNormal",transmission:"csm_Transmission",thickness:"csm_Thickness",iridescence:"csm_Iridescence",pointSize:"csm_PointSize",fragColor:"csm_FragColor",depthAlpha:"csm_DepthAlpha",unlitFac:"csm_UnlitFac",position:"csm_Position",positionRaw:"csm_PositionRaw",normal:"csm_Normal"},w={[`${e.position}`]:"*",[`${e.positionRaw}`]:"*",[`${e.normal}`]:"*",[`${e.depthAlpha}`]:"*",[`${e.pointSize}`]:["PointsMaterial"],[`${e.diffuse}`]:"*",[`${e.fragColor}`]:"*",[`${e.fragNormal}`]:"*",[`${e.unlitFac}`]:"*",[`${e.emissive}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${e.roughness}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${e.metalness}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${e.iridescence}`]:["MeshStandardMaterial","MeshPhysicalMaterial"],[`${e.ao}`]:["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"],[`${e.bump}`]:["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"],[`${e.clearcoat}`]:["MeshPhysicalMaterial"],[`${e.clearcoatRoughness}`]:["MeshPhysicalMaterial"],[`${e.clearcoatNormal}`]:["MeshPhysicalMaterial"],[`${e.transmission}`]:["MeshPhysicalMaterial"],[`${e.thickness}`]:["MeshPhysicalMaterial"]},z={"*":{"#include <lights_physical_fragment>":v.ShaderChunk.lights_physical_fragment,"#include <transmission_fragment>":v.ShaderChunk.transmission_fragment},[`${e.normal}`]:{"#include <beginnormal_vertex>":`
    vec3 objectNormal = ${e.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `},[`${e.position}`]:{"#include <begin_vertex>":`
    vec3 transformed = ${e.position};
  `},[`${e.positionRaw}`]:{"#include <project_vertex>":`
    #include <project_vertex>
    gl_Position = ${e.positionRaw};
  `},[`${e.pointSize}`]:{"gl_PointSize = size;":`
    gl_PointSize = ${e.pointSize};
    `},[`${e.diffuse}`]:{"#include <color_fragment>":`
    #include <color_fragment>
    diffuseColor = ${e.diffuse};
  `},[`${e.fragColor}`]:{"#include <opaque_fragment>":`
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${e.fragColor}, ${e.unlitFac});
  `},[`${e.emissive}`]:{"vec3 totalEmissiveRadiance = emissive;":`
    vec3 totalEmissiveRadiance = ${e.emissive};
    `},[`${e.roughness}`]:{"#include <roughnessmap_fragment>":`
    #include <roughnessmap_fragment>
    roughnessFactor = ${e.roughness};
    `},[`${e.metalness}`]:{"#include <metalnessmap_fragment>":`
    #include <metalnessmap_fragment>
    metalnessFactor = ${e.metalness};
    `},[`${e.ao}`]:{"#include <aomap_fragment>":`
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${e.ao};
    `},[`${e.bump}`]:{"#include <normal_fragment_maps>":`
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = ${e.bump} - (dot(${e.bump}, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `},[`${e.fragNormal}`]:{"#include <normal_fragment_maps>":`
      #include <normal_fragment_maps>
      normal = ${e.fragNormal};
    `},[`${e.depthAlpha}`]:{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${e.depthAlpha} );
    `,"gl_FragColor = packDepthToRGBA( fragCoordZ );":`
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,"gl_FragColor = packDepthToRGBA( dist );":`
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `},[`${e.clearcoat}`]:{"material.clearcoat = clearcoat;":`material.clearcoat = ${e.clearcoat};`},[`${e.clearcoatRoughness}`]:{"material.clearcoatRoughness = clearcoatRoughness;":`material.clearcoatRoughness = ${e.clearcoatRoughness};`},[`${e.clearcoatNormal}`]:{"#include <clearcoat_normal_fragment_begin>":`
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `},[`${e.transmission}`]:{"material.transmission = transmission;":`
      material.transmission = ${e.transmission};
    `},[`${e.thickness}`]:{"material.thickness = thickness;":`
      material.thickness = ${e.thickness};
    `},[`${e.iridescence}`]:{"material.iridescence = iridescence;":`
      material.iridescence = ${e.iridescence};
    `}},j={clearcoat:[e.clearcoat,e.clearcoatNormal,e.clearcoatRoughness],transmission:[e.transmission],iridescence:[e.iridescence]};function U(l){let s=0;for(let _=0;_<l.length;_++)s=l.charCodeAt(_)+(s<<6)+(s<<16)-s;const o=s>>>0;return String(o)}function B(l){try{new l}catch(s){if(s.message.indexOf("is not a constructor")>=0)return!1}return!0}function L(l){return l.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g,"")}class V extends v.Material{constructor({baseMaterial:s,vertexShader:o,fragmentShader:f,uniforms:_,patchMap:I,cacheKey:S,...M}){if(!s)throw new Error("CustomShaderMaterial: baseMaterial is required.");let i;if(B(s)){const t=Object.keys(M).length===0;i=new s(t?void 0:M)}else i=s,Object.assign(i,M);if(["ShaderMaterial","RawShaderMaterial"].includes(i.type))throw new Error(`CustomShaderMaterial does not support ${i.type} as a base material.`);super(),this.uniforms={},this.vertexShader="",this.fragmentShader="";const r=i;r.name=`CustomShaderMaterial<${i.name||i.type}>`,r.update=this.update,r.__csm={prevOnBeforeCompile:i.onBeforeCompile,baseMaterial:i,vertexShader:o,fragmentShader:f,uniforms:_,patchMap:I,cacheKey:S};const n={...r.uniforms||{},..._||{}};r.uniforms=this.uniforms=n,r.vertexShader=this.vertexShader=o||"",r.fragmentShader=this.fragmentShader=f||"",r.update({fragmentShader:r.fragmentShader,vertexShader:r.vertexShader,uniforms:r.uniforms,patchMap:I,cacheKey:S}),Object.assign(this,r);const u=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r));for(const t in u){const d=u[t];(d.get||d.set)&&Object.defineProperty(this,t,d)}return Object.defineProperty(this,"type",{get(){return i.type},set(t){i.type=t}}),this}update({fragmentShader:s,vertexShader:o,uniforms:f,cacheKey:_,patchMap:I}){const S=L(o||""),M=L(s||""),i=this;f&&(i.uniforms=f),o&&(i.vertexShader=o),s&&(i.fragmentShader=s),Object.entries(j).forEach(([a,n])=>{for(const u in n){const t=n[u];(M&&M.includes(t)||S&&S.includes(t))&&(i[a]||(i[a]=1))}});const R=i.__csm.prevOnBeforeCompile,r=(a,n,u)=>{let t,d="";if(n){const c=n.search(/void\s+main\s*\(\s*\)\s*{/);if(c!==-1){d=n.slice(0,c);let m=0,g=-1;for(let h=c;h<n.length;h++)if(n[h]==="{"&&m++,n[h]==="}"&&(m--,m===0)){g=h;break}if(g!==-1){const h=n.slice(c,g+1);t=h.slice(h.indexOf("{")+1,-1)}}else d=n}if(u&&(n&&n.includes(e.fragColor))&&t&&(t=`csm_UnlitFac = 1.0;
`+t),a.includes("//~CSM_DEFAULTS")){a=a.replace("void main() {",`
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${d}
          
          void main() {
          `);const c=a.lastIndexOf("//~CSM_MAIN_END");if(c!==-1){const m=`
            ${t?`${t}`:""}
            //~CSM_MAIN_END
          `;a=a.slice(0,c)+m+a.slice(c)}}else{const c=/void\s*main\s*\(\s*\)\s*{/gm;a=a.replace(c,`
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${u?F:b}
          ${y}
  
          ${d}
          
          void main() {
            {
              ${O}
            }
            ${u?k:x}

            ${t?`${t}`:""}
            //~CSM_MAIN_END
          `)}return a};i.onBeforeCompile=(a,n)=>{R==null||R(a,n);const u=I||{},t=i.type,d=t?`#define IS_${t.toUpperCase()};
`:`#define IS_UNKNOWN;
`;a.vertexShader=d+`#define IS_VERTEX
`+a.vertexShader,a.fragmentShader=d+`#define IS_FRAGMENT
`+a.fragmentShader;const C=c=>{for(const m in c){const g=m==="*"||S&&S.includes(m);if(m==="*"||M&&M.includes(m)||g){const p=w[m];if(p&&p!=="*"&&(Array.isArray(p)?!p.includes(t):p!==t)){console.error(`CustomShaderMaterial: ${m} is not available in ${t}. Shader cannot compile.`);return}const $=c[m];for(const E in $){const A=$[E];if(typeof A=="object"){const N=A.type,P=A.value;N==="fs"?a.fragmentShader=a.fragmentShader.replace(E,P):N==="vs"&&(a.vertexShader=a.vertexShader.replace(E,P))}else A&&(a.vertexShader=a.vertexShader.replace(E,A),a.fragmentShader=a.fragmentShader.replace(E,A))}}}};C(z),C(u),a.vertexShader=r(a.vertexShader,S,!1),a.fragmentShader=r(a.fragmentShader,M,!0),f&&(a.uniforms={...a.uniforms,...i.uniforms}),i.uniforms=a.uniforms};const T=i.customProgramCacheKey;i.customProgramCacheKey=()=>((_==null?void 0:_())||U((S||"")+(M||"")))+(T==null?void 0:T.call(i)),i.needsUpdate=!0}clone(){const s=this;return new s.constructor({baseMaterial:s.__csm.baseMaterial.clone(),vertexShader:s.__csm.vertexShader,fragmentShader:s.__csm.fragmentShader,uniforms:s.__csm.uniforms,patchMap:s.__csm.patchMap,cacheKey:s.__csm.cacheKey})}}module.exports=V;
//# sourceMappingURL=three-custom-shader-material.cjs.js.map
